## Dominio de colis√£o: 
Quando uma m√°quina est√° transmitindo algum sinal, o dom√≠nio fica bloqueado, causando colis√£o. Um bom exemplo disso √© a rede Wi-Fi, visto que quando uma m√°quina est√° transmitindo sinal em um canal, a outra n√£o consegue (ficando bloqueada). Esse dom√≠nio √© muito dif√≠cil de ocorrer em redes cabeadas. √â para imaginar como se tivesse um fio que liga todos os computadores e se um envia sinal, os outros param.

## Comando Kathara Settings no CMD: 
Consegue ver as configura√ß√µes para serem realizadas na m√°quina virtual. Com esse comando, √© poss√≠vel selecionar as imagens que voc√™ quer carregar, habilitar IPV4, entre outros.

## Kathar√° providencia tr√™s comandos:
* v-prefixed commands -> Para instalar uma m√°quina em tempo real, s√£o utilizados comandos do tipo V, ent√£o com a rede rodando, adicionar um novo dispositivo.

* l-prefixed commands -> Utiliza-se esse comando para adicionar m√°quinas, ou seja, instancia o pr√≥prio cen√°rio e sobe tudo de uma vez, e para isso, usam comandos do tipo L.

* global commands -> Funcionam tanto em tempo real quando em pr√© configura√ß√£o, para capturar informa√ß√µes da m√°quina e da rede

## Comandos kathara:
* Todos os comandos devem ter prefixo kathara e se for inst√¢ncia atual de rede, deve utilizar o prefixo 'v'.

* kathara check -> Validar a rede e o docker que est√° sendo executado e fazer testes
* kathara vstart -n pc1 --eth 0:A -> Cria uma m√°quina na sua rede

* Se ocorrer o erro **"DockerPluginError"** Kathara has been left in an incosistent state‚Äù significa que a √∫ltima inst√¢ncia do Kathara n√£o foi finalizada corretamente, sendo necess√°rio que execute o comando **"kathara wipe"**, para limpar a mem√≥ria.


* **"kathara vclean -n [nomeDispositivo]"**: comando para apagar um elemento da rede. 

* Comando 0:A : significa que :A √© o dom√≠nio de colis√£o e 0 porque √© o primeiro dispositivo
:B por exemplo seria o dom√≠nio de colis√£o B.





## Anota√ß√µes gerais v√°lidas... üìó


Sempre que ser criado um container (PC1, PC2, PC3), ter√° dispon√≠vel uma pasta /hosthome que ter√° todos os arquivos. Para acessar as informa√ß√µes compartilhadas no dispositivo host, precisa acessar a pasta /shared.

Para acessar o arquivo de log de uma m√°quina, √© preciso habilitar a pasta do host, copiar o arquivo do PC1 via linha de comando para a pasta do host via /shared.
/shared -> Acessar pelo host
/hosthome -> Acessar pelas m√°quinas

Agora, para executar um laborat√≥rio exemplo completo, utilizamos os comandos do tipo L, visto que iremos realizar toda a configura√ß√£o previa da m√°quina e depois subir toda a rede de uma vez.

Interface √© a placa de rede do dispositivo:
r1[0]="A"
r1[1]="B"
r1[image]="kathara/base"

Aqui, estamos definindo a interface 0 do roteador no dom√≠nio de colis√£o A, depois estamos definindo a interface 1 do roteador no dom√≠nio de colis√£o B, e por fim, definindo a imagem do dispositivo criado como a imagem base.

Quando tentamos acessar a interface 0 do roteador 1 atrav√©s da interface 0 do pc1, conseguimos com sucesso. Contudo, quando tentamos acessar a interface 1 do roteador 1 atrav√©s da interface 0 do pc1, n√£o conseguimos.
Porque n√£o √© poss√≠vel acessar interfaces em diferentes dom√≠nios?

√â uma quest√£o de configura√ß√£o. O computador foi configurado apenas na rede 195 e n√£o consegue enviar pacote de dados para outras redes. Precisa adicionar um comando para que, caso ele n√£o consiga alcan√ßar a rede, ele manda para o roteador 1 que ele provavelmente vai saber o que fazer com isso. Basicamente, o que estamos criando √© uma tabela de rotas est√°ticas.
Tabela rotas est√°ticas -> Qualquer pacote destinado a algum ip espec√≠fico, deve ser direcionado para outros dispositivo (no nosso caso, uma tabela de rota est√°tica entre o pc1 e o r1.
O r1 est√° na rede 195.11.14 e 100.0.0.9, ent√£o quando o pc1 enviou para a rede 100.0.0.9, ele n√£o sabe o que fazer, ent√£o envia para o roteador1, que provavelmente sabe. Como o roteador 1 est√° conectado na rede 100.0.0.9, ele consegue receber o pacote de dados e transmitir para essa nova rede, constando como ativa.

O pc1 n√£o consegue se comunicar com a interface de rede do r2. Para resolver isso, utiliza o tcpdump -tenni eth1 no roteador 2, para ele se conectar com o pc. Com esse comando, voc√™ consegue capturar e analisar o trafego de rede que passa por uma inst√¢ncia de rede em espec√≠fico, nesse caso, o eth1.

Contudo, o PC1 conseguiu enviar os dados, o R2 recebeu, mas n√£o teve pacote de resposta, ent√£o deu falha. Isso ocorre porque o R2 s√≥ tem rota para a rede 100.0.0.9 e 200, ent√£o √© necess√°rio configurar uma rota para alguma outra rede. Nesse caso, utilizamos o comando "ip route add 195.11.14.0/24 via 100.0.0.9 dev eth1". Nesse caso estamos dizendo que a rede "195.11.14.0/24" est√° acess√≠vel atrav√©s da rede "100.0.0.9" e utilizando a interface "eth1", conforme o desenho esquem√°tico.

O TCDUMP, em resumo, √© um sniffer de rede, ou seja, ele recebe os pacotes mas n√£o injeta eles. Em reusmo, ele √© passivo na rede, captura todos os pacotes e consegue utiliz√°-los, mas se n√£o est√° na rede, ele n√£o d√° retorno.

